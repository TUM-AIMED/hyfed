"""
    Utility functions

    Copyright 2021 Reza NasiriGerdeh. All Rights Reserved.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
"""

import numpy as np
from hyfed_client.util.data_type import DataType

import logging
logger = logging.getLogger(__name__)

# noise values are generated in the range [0, largest_prime) for integers >= 0
largest_prime_non_negative_int54 = 18014398509481951  # largest prime number that can fit in 54 bits

# for integers < 0 and floating-point parameters,
# the noise is generated by Gaussian distribution with mean=0 and std=gaussian_std


def make_noisy(original_value, data_type, gaussian_std):
    """ Generate noise value with the same shape as the original value,
        add it to the original value, and return both noise and noisy value
        integers >= 0 are masked with integer noise
        integers < 0 or real-valued parameters are masked with Gaussian noise
        with mean of zero and standard deviation of gaussian_std
    """

    try:
        if data_type == DataType.NON_NEGATIVE_INTEGER :
            noise = np.random.randint(low=0, high=largest_prime_non_negative_int54)
            noisy_value = (original_value + noise) % largest_prime_non_negative_int54  # modular arithmetic
            return noisy_value, noise

        if data_type == DataType.NEGATIVE_INTEGER or data_type == DataType.FLOAT:
            noise = np.random.normal(loc=0, scale=gaussian_std)
            noisy_value = original_value + noise
            return noisy_value, noise

        if data_type == DataType.NUMPY_ARRAY_NON_NEGATIVE_INTEGER:
            noise = np.random.randint(low=0, high=largest_prime_non_negative_int54, size=original_value.shape)
            noisy_value = (original_value + noise) % largest_prime_non_negative_int54  # modular arithmetic
            return noisy_value, noise

        if data_type == DataType.NUMPY_ARRAY_NEGATIVE_INTEGER or data_type == DataType.NUMPY_ARRAY_FLOAT:
                noise = np.random.normal(loc=0, scale=gaussian_std, size=original_value.shape)
                noisy_value = original_value + noise
                return noisy_value, noise

        if data_type == DataType.LIST_NUMPY_ARRAY_NON_NEGATIVE_INTEGER:
            noise_list = []
            noisy_values = []
            for numpy_array in original_value:
                noise = np.random.randint(low=0, high=largest_prime_non_negative_int54, size=numpy_array.shape)
                noisy_value = (numpy_array + noise) % largest_prime_non_negative_int54  # modular arithmetic

                noise_list.append(noise)
                noisy_values.append(noisy_value)

            return noisy_values, noise_list

        if data_type == DataType.LIST_NUMPY_ARRAY_NEGATIVE_INTEGER or data_type == DataType.LIST_NUMPY_ARRAY_FLOAT:
            noise_list = []
            noisy_values = []
            for numpy_array in original_value:
                noise = np.random.normal(loc=0, scale=gaussian_std, size=numpy_array.shape)
                noisy_value = numpy_array + noise

                noise_list.append(noise)
                noisy_values.append(noisy_value)

            return noisy_values, noise_list

        return None, None

    except Exception as exp:
        print(exp)
        return None, None
